#/bin/bash

if [[ ${#} -lt 1 ]] ; then
        echo "At least 1 argument expected"
        exit 1
fi

if [[ ${1} == "-n" ]] ; then
        N=${2}
        shift 2
else
        N=10
fi

while [[ ${#} -ne 0 ]] ; do
        IDF=$(basename ${1} | sed 's/[.]log$//')
        while read line ; do
                timestamp=$(echo "${line}" | awk '{print $1 " " $2}')
                data=$(echo "${line}" | awk '{for (i=3;i<=NF;i++) printf "%s ",$i}')
                result+="${timestamp} ${IDF} ${data}"
                result+=$'\n'
        done < <(cat "${1}" | tail -n ${N})
        shift
done

echo "${result}" | sort

#Напишете шел скрипт, който приема множество параметри. Общ вид на извикване:
#./foo.sh [-n N] FILE1...
#В общия случай параметрите се третират като имена на (.log) файлове, които трябва да бъдат
#обработени от скрипта, със следното изключение: ако първият параметър е стрингът -n, то вторият параметър е число,
#дефиниращо стойност на променливата N, която ще ползваме в скрипта.
#Въвеждаме понятието идентификатор на файл (ИДФ), което се състои от името на даден файл
#без разширението .log. За удобство приемаме, че скриптът:
#• ще бъде извикван с аргументи имена на файлове, винаги завършващи на .log
#• няма да бъде извикван с аргументи имена на файлове с еднакъв ИДФ.
#Лог файловете са текстови, като всеки ред има следния формат:
#• време: timestamp във формат YYYY-MM-DD HH:MM:SS
#• интервал
#• данни: поредица от символи с произволна дължина
#За удобство приемаме, че редовете във всеки файл са сортирани по време възходящо.
#Примерно съдържание на даден лог файл:
#2019-05-05 06:26:54 orthanc rsyslogd: rsyslogd was HUPed
#2019-05-06 06:30:32 orthanc rsyslogd: rsyslogd was HUPed
#2019-05-06 10:48:29 orthanc kernel: [1725379.728871] Chrome_~dThread[876]: segfault
#Скриптът трябва да извежда на STDOUT последните N реда (ако N не е дефинирано - 10 реда) от
#всеки файл, в следния формат:
#• timestamp във формат YYYY-MM-DD HH:MM:SS
#• интервал
#• ИДФ
#• интервал
#• данни
#Изходът трябва да бъде глобално сортиран по време възходящо